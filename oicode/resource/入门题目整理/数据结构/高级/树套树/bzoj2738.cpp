/*
话说这题做法真是神奇
首先大多数人用的是整体二分
n^2*log^3n+qlogn
整体二分用在高维上好像很优越，
整体二分部分的复杂度随维度增加只增加常数

当然还是可以分块，问题不好搞怎么办，分块大法好
n^(10/3)*logn+qn^(3/4)*logn
分块大小n^(2/3),块内平衡树维护
时间复杂度上预计会比整体二分慢40倍、要挂

科学的分块：（搬运）
我们将这n*n个数排序 分n次插入 每次插入n个
每次插入后 去链表上处理尚未出解的询问(我懒得写链表写了并查集) 如果当前询问的子矩阵内已经插入大于等于k个数 那么答案一定在当次插入的n个数中 暴力查找即可
时间复杂度O(n^3+nq) 好卡……

每次插入后、n^2处理(1,1)-(i,j)的数字个数 ，然后O(q)检查所有询问

所以考虑二维莫队（即四个关键字、或者叫四维莫队）\oh我的想象力溢出了
这个单维度调整的代价有点大、不再是一个关键字的问题、而是一组
先考虑普通三维：复杂度=n^(1+(1/3))*(单关键字+1的复杂度)
所以四维n^3（n^2.5*n^0.5）的复杂度 那么能不能快速单关键字+1呢？
so，有没有只有高维莫队能做的题呢 好像高维莫队的转移复杂度很优越、其他好像有点坑

其实可以树状数组套主席树
两个logn、无压力
其实我不想写了，记着空间开n^2logn就对了
*/
#include<cstdio>
#include<iostream>
#define N 505
#define M
using namespace std;
int main() {


	return 0;
}
